<# // Copyright (c) Microsoft Corporation. All rights reserved. #>
<# // Licensed under the MIT License. #>

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<#
    var maxargs = 15;
    var argsComma = new Dictionary<int, string>();
    var argsDef = new Dictionary<int, string>();
    var argsDefWithName = new Dictionary<int, string>();
    var args = new Dictionary<int, string>();
    for (var arg = 0; arg < maxargs; arg++)  {

        var argsCommaStr = string.Empty;
        var argDefStr = string.Empty;
        var argsDefWithNameStr = string.Empty;
        var argsStr = string.Empty;

        if (arg > 0)
        {
            argsCommaStr = ", ";
            argDefStr = "object";
            argsDefWithNameStr = "object arg0";
            argsStr = "arg0";
        }
        for (var i = 1; i < arg; i++)  {
            argDefStr += ", object";
            argsDefWithNameStr += ", object arg" + i;
            argsStr += ", arg" + i;
        }
        argsDef.Add(arg, argDefStr);
        argsDefWithName.Add(arg, argsDefWithNameStr);
        args.Add(arg, argsStr);
        argsComma.Add(arg, argsCommaStr);
    }
#>

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// ==============================================
// This file is autogenerated
// ==============================================
// Underscore _System assembly will be treated as regular System namespace by ImportModule function of Instrumentation Engine.
// This is done to avoid conflicts during compilation

namespace _System.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.Threading;

    using Microsoft.Diagnostics.Instrumentation.Extensions.Base;

    /// <summary>
    /// This class defines public contract to register new callbacks
    /// </summary>
    public partial class DebuggerHiddenAttribute : Attribute
    {
<#
    for (var arg = 0; arg < maxargs; arg++)  {
#>
        /// <summary>
        /// Adds callbacks for the specified method Id accepting <#=arg#> arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting <#=arg#> args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and <#=arg#> args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and <#=arg#> args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object<#=argsComma[arg]#><#=argsDef[arg]#>> onBegin,
            Func<object, object, object<#=argsComma[arg]#><#=argsDef[arg]#>> onEnd,
            Action<object, Exception<#=argsComma[arg]#><#=argsDef[arg]#>> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock<#=arg#>, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock<#=arg#>
                        var newBeginCallbacks<#=arg#> = new Dictionary<int, Func<object<#=argsComma[arg]#><#=argsDef[arg]#>>>(BCB<int>.callbacks<#=arg#>);
                        var newEndCallbacks<#=arg#> = new Dictionary<int, Func<object, object, object<#=argsComma[arg]#><#=argsDef[arg]#>>>(ECB<int>.callbacks<#=arg#>);
                        var newExceptionCallbacks<#=arg#> = new Dictionary<int, Action<object, Exception<#=argsComma[arg]#><#=argsDef[arg]#>>>(ExCB<int>.callbacks<#=arg#>);

                        newBeginCallbacks<#=arg#>.Add(methodId, onBegin);
                        newEndCallbacks<#=arg#>.Add(methodId, onEnd);
                        newExceptionCallbacks<#=arg#>.Add(methodId, onException);

                        BCB<int>.callbacks<#=arg#> = newBeginCallbacks<#=arg#>;
                        ECB<int>.callbacks<#=arg#> = newEndCallbacks<#=arg#>;
                        ExCB<int>.callbacks<#=arg#> = newExceptionCallbacks<#=arg#>;
                    }
                    finally
                    {
                        BCB<int>.Lock<#=arg#> = 0;
                    }

                    break;
                }

                // some other thread updated Lock<#=arg#>; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

<#
}
#>
#pragma warning disable CA1506 // Avoid excessive class coupling
#pragma warning disable CA1502 // Avoid excessive complexity
        public static void ApplicationInsights_RemoveCallbacks(int methodId, int argsCount)
        {
            switch (argsCount)
            {
<#
    for (var arg = 0; arg < maxargs; arg++)  {
#>
                case <#=arg#> :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock<#=arg#>, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock<#=arg#>
                                var newBeginCallbacks<#=arg#> = new Dictionary<int, Func<object<#=argsComma[arg]#><#=argsDef[arg]#>>>(BCB<int>.callbacks<#=arg#>);
                                var newEndCallbacks<#=arg#> = new Dictionary<int, Func<object, object, object<#=argsComma[arg]#><#=argsDef[arg]#>>>(ECB<int>.callbacks<#=arg#>);
                                var newExceptionCallbacks<#=arg#> = new Dictionary<int, Action<object, Exception<#=argsComma[arg]#><#=argsDef[arg]#>>>(ExCB<int>.callbacks<#=arg#>);

                                newBeginCallbacks<#=arg#>.Remove(methodId);
                                newEndCallbacks<#=arg#>.Remove(methodId);
                                newExceptionCallbacks<#=arg#>.Remove(methodId);

                                BCB<int>.callbacks<#=arg#> = newBeginCallbacks<#=arg#>;
                                ECB<int>.callbacks<#=arg#> = newEndCallbacks<#=arg#>;
                                ExCB<int>.callbacks<#=arg#> = newExceptionCallbacks<#=arg#>;
                            }
                            finally
                            {
                                BCB<int>.Lock<#=arg#> = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock<#=arg#>; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
<#
    }
#>
            }
        }
#pragma warning restore CA1506 // Avoid excessive class coupling
#pragma warning restore CA1502 // Avoid excessive complexity
    }
}

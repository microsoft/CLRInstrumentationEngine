<# // Copyright (c) Microsoft Corporation. All rights reserved. #>
<# // Licensed under the MIT License. #>

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var maxargs = 7;
    var argsComma = new Dictionary<int, string>();
    var argsDef = new Dictionary<int, string>();
    var argsDefWithName = new Dictionary<int, string>();
    var args = new Dictionary<int, string>();
    for (var arg = 0; arg < maxargs; arg++)  {

        var argsCommaStr = string.Empty;
        var argDefStr = string.Empty;
        var argsDefWithNameStr = string.Empty;
        var argsStr = string.Empty;

        if (arg > 0)
        {
            argsCommaStr = ", ";
            argDefStr = "object";
            argsDefWithNameStr = "object arg0";
            argsStr = "arg0";
        }
        for (var i = 1; i < arg; i++)  {
            argDefStr += ", object";
            argsDefWithNameStr += ", object arg" + i;
            argsStr += ", arg" + i;
        }
        argsDef.Add(arg, argDefStr);
        argsDefWithName.Add(arg, argsDefWithNameStr);
        args.Add(arg, argsStr);
        argsComma.Add(arg, argsCommaStr);
    }
#>

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//==============================================
//This file is autogenerated
//==============================================
//Underscore _System assembly will be treated as regular System namespace by ImportModule function of Intstrumentation Engine.
//This is done to avoid conflicts during compilation

namespace _System.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.Threading;

    using Microsoft.Diagnostics.Instrumentation.Extensions.Base;

    /// <summary>
    /// This class defines public contract to register new callbacks
    /// </summary>
    public partial class DebuggerHiddenAttribute : Attribute
    {
<#
    for (var arg = 0; arg < maxargs; arg++)  {
#>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object<#=argsComma[arg]#><#=argsDef[arg]#>> onBegin,
            Func<object, object, object<#=argsComma[arg]#><#=argsDef[arg]#>> onEnd,
            Action<object, Exception<#=argsComma[arg]#><#=argsDef[arg]#>> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock<#=arg#>, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock<#=arg#>
                        var newBeginCallbacks<#=arg#> = new Dictionary<int, Func<object<#=argsComma[arg]#><#=argsDef[arg]#>>>(BCB<int>.callbacks<#=arg#>);
                        var newEndCallbacks<#=arg#> = new Dictionary<int, Func<object, object, object<#=argsComma[arg]#><#=argsDef[arg]#>>>(ECB<int>.callbacks<#=arg#>);
                        var newExceptionCallbacks<#=arg#> = new Dictionary<int, Action<object, Exception<#=argsComma[arg]#><#=argsDef[arg]#>>>(ExCB<int>.callbacks<#=arg#>);

                        newBeginCallbacks<#=arg#>.Add(methodId, onBegin);
                        newEndCallbacks<#=arg#>.Add(methodId, onEnd);
                        newExceptionCallbacks<#=arg#>.Add(methodId, onException);

                        BCB<int>.callbacks<#=arg#> = newBeginCallbacks<#=arg#>;
                        ECB<int>.callbacks<#=arg#> = newEndCallbacks<#=arg#>;
                        ExCB<int>.callbacks<#=arg#> = newExceptionCallbacks<#=arg#>;
                    }
                    finally
                    {
                        BCB<int>.Lock<#=arg#> = 0;
                    }

                    break;
                }

                // some other thread updated Lock<#=arg#>; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

<#
}
#>
        public static void ApplicationInsights_RemoveCallbacks(int methodId, int argsCount)
        {
            switch (argsCount)
            {
<#
    for (var arg = 0; arg < maxargs; arg++)  {
#>
                case <#=arg#> :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock<#=arg#>, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock<#=arg#>
                                var newBeginCallbacks<#=arg#> = new Dictionary<int, Func<object<#=argsComma[arg]#><#=argsDef[arg]#>>>(BCB<int>.callbacks<#=arg#>);
                                var newEndCallbacks<#=arg#> = new Dictionary<int, Func<object, object, object<#=argsComma[arg]#><#=argsDef[arg]#>>>(ECB<int>.callbacks<#=arg#>);
                                var newExceptionCallbacks<#=arg#> = new Dictionary<int, Action<object, Exception<#=argsComma[arg]#><#=argsDef[arg]#>>>(ExCB<int>.callbacks<#=arg#>);

                                newBeginCallbacks<#=arg#>.Remove(methodId);
                                newEndCallbacks<#=arg#>.Remove(methodId);
                                newExceptionCallbacks<#=arg#>.Remove(methodId);

                                BCB<int>.callbacks<#=arg#> = newBeginCallbacks<#=arg#>;
                                ECB<int>.callbacks<#=arg#> = newEndCallbacks<#=arg#>;
                                ExCB<int>.callbacks<#=arg#> = newExceptionCallbacks<#=arg#>;
                            }
                            finally
                            {
                                BCB<int>.Lock<#=arg#> = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock<#=arg#>; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
<#
    }
#>
            }
        }
    }
}

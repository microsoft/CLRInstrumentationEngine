


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// ==============================================
// This file is autogenerated
// ==============================================
// Underscore _System assembly will be treated as regular System namespace by ImportModule function of Instrumentation Engine.
// This is done to avoid conflicts during compilation

namespace _System.Diagnostics
{
    using System;
    using System.Collections.Generic;
    using System.Threading;

    using Microsoft.Diagnostics.Instrumentation.Extensions.Base;

    /// <summary>
    /// This class defines public contract to register new callbacks
    /// </summary>
    public partial class DebuggerHiddenAttribute : Attribute
    {
        /// <summary>
        /// Adds callbacks for the specified method Id accepting 0 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 0 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 0 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 0 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object> onBegin,
            Func<object, object, object> onEnd,
            Action<object, Exception> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock0, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock0
                        var newBeginCallbacks0 = new Dictionary<int, Func<object>>(BCB<int>.callbacks0);
                        var newEndCallbacks0 = new Dictionary<int, Func<object, object, object>>(ECB<int>.callbacks0);
                        var newExceptionCallbacks0 = new Dictionary<int, Action<object, Exception>>(ExCB<int>.callbacks0);

                        newBeginCallbacks0.Add(methodId, onBegin);
                        newEndCallbacks0.Add(methodId, onEnd);
                        newExceptionCallbacks0.Add(methodId, onException);

                        BCB<int>.callbacks0 = newBeginCallbacks0;
                        ECB<int>.callbacks0 = newEndCallbacks0;
                        ExCB<int>.callbacks0 = newExceptionCallbacks0;
                    }
                    finally
                    {
                        BCB<int>.Lock0 = 0;
                    }

                    break;
                }

                // some other thread updated Lock0; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 1 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 1 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 1 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 1 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object> onBegin,
            Func<object, object, object, object> onEnd,
            Action<object, Exception, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock1, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock1
                        var newBeginCallbacks1 = new Dictionary<int, Func<object, object>>(BCB<int>.callbacks1);
                        var newEndCallbacks1 = new Dictionary<int, Func<object, object, object, object>>(ECB<int>.callbacks1);
                        var newExceptionCallbacks1 = new Dictionary<int, Action<object, Exception, object>>(ExCB<int>.callbacks1);

                        newBeginCallbacks1.Add(methodId, onBegin);
                        newEndCallbacks1.Add(methodId, onEnd);
                        newExceptionCallbacks1.Add(methodId, onException);

                        BCB<int>.callbacks1 = newBeginCallbacks1;
                        ECB<int>.callbacks1 = newEndCallbacks1;
                        ExCB<int>.callbacks1 = newExceptionCallbacks1;
                    }
                    finally
                    {
                        BCB<int>.Lock1 = 0;
                    }

                    break;
                }

                // some other thread updated Lock1; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 2 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 2 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 2 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 2 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object> onBegin,
            Func<object, object, object, object, object> onEnd,
            Action<object, Exception, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock2, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock2
                        var newBeginCallbacks2 = new Dictionary<int, Func<object, object, object>>(BCB<int>.callbacks2);
                        var newEndCallbacks2 = new Dictionary<int, Func<object, object, object, object, object>>(ECB<int>.callbacks2);
                        var newExceptionCallbacks2 = new Dictionary<int, Action<object, Exception, object, object>>(ExCB<int>.callbacks2);

                        newBeginCallbacks2.Add(methodId, onBegin);
                        newEndCallbacks2.Add(methodId, onEnd);
                        newExceptionCallbacks2.Add(methodId, onException);

                        BCB<int>.callbacks2 = newBeginCallbacks2;
                        ECB<int>.callbacks2 = newEndCallbacks2;
                        ExCB<int>.callbacks2 = newExceptionCallbacks2;
                    }
                    finally
                    {
                        BCB<int>.Lock2 = 0;
                    }

                    break;
                }

                // some other thread updated Lock2; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 3 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 3 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 3 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 3 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object> onBegin,
            Func<object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock3, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock3
                        var newBeginCallbacks3 = new Dictionary<int, Func<object, object, object, object>>(BCB<int>.callbacks3);
                        var newEndCallbacks3 = new Dictionary<int, Func<object, object, object, object, object, object>>(ECB<int>.callbacks3);
                        var newExceptionCallbacks3 = new Dictionary<int, Action<object, Exception, object, object, object>>(ExCB<int>.callbacks3);

                        newBeginCallbacks3.Add(methodId, onBegin);
                        newEndCallbacks3.Add(methodId, onEnd);
                        newExceptionCallbacks3.Add(methodId, onException);

                        BCB<int>.callbacks3 = newBeginCallbacks3;
                        ECB<int>.callbacks3 = newEndCallbacks3;
                        ExCB<int>.callbacks3 = newExceptionCallbacks3;
                    }
                    finally
                    {
                        BCB<int>.Lock3 = 0;
                    }

                    break;
                }

                // some other thread updated Lock3; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 4 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 4 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 4 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 4 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock4, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock4
                        var newBeginCallbacks4 = new Dictionary<int, Func<object, object, object, object, object>>(BCB<int>.callbacks4);
                        var newEndCallbacks4 = new Dictionary<int, Func<object, object, object, object, object, object, object>>(ECB<int>.callbacks4);
                        var newExceptionCallbacks4 = new Dictionary<int, Action<object, Exception, object, object, object, object>>(ExCB<int>.callbacks4);

                        newBeginCallbacks4.Add(methodId, onBegin);
                        newEndCallbacks4.Add(methodId, onEnd);
                        newExceptionCallbacks4.Add(methodId, onException);

                        BCB<int>.callbacks4 = newBeginCallbacks4;
                        ECB<int>.callbacks4 = newEndCallbacks4;
                        ExCB<int>.callbacks4 = newExceptionCallbacks4;
                    }
                    finally
                    {
                        BCB<int>.Lock4 = 0;
                    }

                    break;
                }

                // some other thread updated Lock4; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 5 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 5 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 5 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 5 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock5, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock5
                        var newBeginCallbacks5 = new Dictionary<int, Func<object, object, object, object, object, object>>(BCB<int>.callbacks5);
                        var newEndCallbacks5 = new Dictionary<int, Func<object, object, object, object, object, object, object, object>>(ECB<int>.callbacks5);
                        var newExceptionCallbacks5 = new Dictionary<int, Action<object, Exception, object, object, object, object, object>>(ExCB<int>.callbacks5);

                        newBeginCallbacks5.Add(methodId, onBegin);
                        newEndCallbacks5.Add(methodId, onEnd);
                        newExceptionCallbacks5.Add(methodId, onException);

                        BCB<int>.callbacks5 = newBeginCallbacks5;
                        ECB<int>.callbacks5 = newEndCallbacks5;
                        ExCB<int>.callbacks5 = newExceptionCallbacks5;
                    }
                    finally
                    {
                        BCB<int>.Lock5 = 0;
                    }

                    break;
                }

                // some other thread updated Lock5; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 6 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 6 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 6 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 6 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock6, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock6
                        var newBeginCallbacks6 = new Dictionary<int, Func<object, object, object, object, object, object, object>>(BCB<int>.callbacks6);
                        var newEndCallbacks6 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks6);
                        var newExceptionCallbacks6 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object>>(ExCB<int>.callbacks6);

                        newBeginCallbacks6.Add(methodId, onBegin);
                        newEndCallbacks6.Add(methodId, onEnd);
                        newExceptionCallbacks6.Add(methodId, onException);

                        BCB<int>.callbacks6 = newBeginCallbacks6;
                        ECB<int>.callbacks6 = newEndCallbacks6;
                        ExCB<int>.callbacks6 = newExceptionCallbacks6;
                    }
                    finally
                    {
                        BCB<int>.Lock6 = 0;
                    }

                    break;
                }

                // some other thread updated Lock6; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 7 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 7 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 7 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 7 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock7, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock7
                        var newBeginCallbacks7 = new Dictionary<int, Func<object, object, object, object, object, object, object, object>>(BCB<int>.callbacks7);
                        var newEndCallbacks7 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks7);
                        var newExceptionCallbacks7 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object>>(ExCB<int>.callbacks7);

                        newBeginCallbacks7.Add(methodId, onBegin);
                        newEndCallbacks7.Add(methodId, onEnd);
                        newExceptionCallbacks7.Add(methodId, onException);

                        BCB<int>.callbacks7 = newBeginCallbacks7;
                        ECB<int>.callbacks7 = newEndCallbacks7;
                        ExCB<int>.callbacks7 = newExceptionCallbacks7;
                    }
                    finally
                    {
                        BCB<int>.Lock7 = 0;
                    }

                    break;
                }

                // some other thread updated Lock7; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 8 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 8 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 8 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 8 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock8, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock8
                        var newBeginCallbacks8 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks8);
                        var newEndCallbacks8 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks8);
                        var newExceptionCallbacks8 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks8);

                        newBeginCallbacks8.Add(methodId, onBegin);
                        newEndCallbacks8.Add(methodId, onEnd);
                        newExceptionCallbacks8.Add(methodId, onException);

                        BCB<int>.callbacks8 = newBeginCallbacks8;
                        ECB<int>.callbacks8 = newEndCallbacks8;
                        ExCB<int>.callbacks8 = newExceptionCallbacks8;
                    }
                    finally
                    {
                        BCB<int>.Lock8 = 0;
                    }

                    break;
                }

                // some other thread updated Lock8; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 9 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 9 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 9 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 9 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock9, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock9
                        var newBeginCallbacks9 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks9);
                        var newEndCallbacks9 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks9);
                        var newExceptionCallbacks9 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks9);

                        newBeginCallbacks9.Add(methodId, onBegin);
                        newEndCallbacks9.Add(methodId, onEnd);
                        newExceptionCallbacks9.Add(methodId, onException);

                        BCB<int>.callbacks9 = newBeginCallbacks9;
                        ECB<int>.callbacks9 = newEndCallbacks9;
                        ExCB<int>.callbacks9 = newExceptionCallbacks9;
                    }
                    finally
                    {
                        BCB<int>.Lock9 = 0;
                    }

                    break;
                }

                // some other thread updated Lock9; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 10 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 10 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 10 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 10 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock10, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock10
                        var newBeginCallbacks10 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks10);
                        var newEndCallbacks10 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks10);
                        var newExceptionCallbacks10 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks10);

                        newBeginCallbacks10.Add(methodId, onBegin);
                        newEndCallbacks10.Add(methodId, onEnd);
                        newExceptionCallbacks10.Add(methodId, onException);

                        BCB<int>.callbacks10 = newBeginCallbacks10;
                        ECB<int>.callbacks10 = newEndCallbacks10;
                        ExCB<int>.callbacks10 = newExceptionCallbacks10;
                    }
                    finally
                    {
                        BCB<int>.Lock10 = 0;
                    }

                    break;
                }

                // some other thread updated Lock10; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 11 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 11 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 11 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 11 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock11, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock11
                        var newBeginCallbacks11 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks11);
                        var newEndCallbacks11 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks11);
                        var newExceptionCallbacks11 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks11);

                        newBeginCallbacks11.Add(methodId, onBegin);
                        newEndCallbacks11.Add(methodId, onEnd);
                        newExceptionCallbacks11.Add(methodId, onException);

                        BCB<int>.callbacks11 = newBeginCallbacks11;
                        ECB<int>.callbacks11 = newEndCallbacks11;
                        ExCB<int>.callbacks11 = newExceptionCallbacks11;
                    }
                    finally
                    {
                        BCB<int>.Lock11 = 0;
                    }

                    break;
                }

                // some other thread updated Lock11; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 12 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 12 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 12 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 12 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock12, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock12
                        var newBeginCallbacks12 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks12);
                        var newEndCallbacks12 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks12);
                        var newExceptionCallbacks12 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks12);

                        newBeginCallbacks12.Add(methodId, onBegin);
                        newEndCallbacks12.Add(methodId, onEnd);
                        newExceptionCallbacks12.Add(methodId, onException);

                        BCB<int>.callbacks12 = newBeginCallbacks12;
                        ECB<int>.callbacks12 = newEndCallbacks12;
                        ExCB<int>.callbacks12 = newExceptionCallbacks12;
                    }
                    finally
                    {
                        BCB<int>.Lock12 = 0;
                    }

                    break;
                }

                // some other thread updated Lock12; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 13 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 13 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 13 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 13 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock13, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock13
                        var newBeginCallbacks13 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks13);
                        var newEndCallbacks13 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks13);
                        var newExceptionCallbacks13 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks13);

                        newBeginCallbacks13.Add(methodId, onBegin);
                        newEndCallbacks13.Add(methodId, onEnd);
                        newExceptionCallbacks13.Add(methodId, onException);

                        BCB<int>.callbacks13 = newBeginCallbacks13;
                        ECB<int>.callbacks13 = newEndCallbacks13;
                        ExCB<int>.callbacks13 = newExceptionCallbacks13;
                    }
                    finally
                    {
                        BCB<int>.Lock13 = 0;
                    }

                    break;
                }

                // some other thread updated Lock13; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

        /// <summary>
        /// Adds callbacks for the specified method Id accepting 14 arguments.
        /// </summary>
        /// <param name="methodId">The id of the method the callbacks are for.</param>
        /// <param name="onBegin">A function accepting 14 args and returns an optional context object.</param>
        /// <param name="onEnd">
        /// A function accepting a context object, the intercepted return value, and 14 args. It should the value
        /// that will be actually returned to the caller (pass through argument 2 to preserve the intercepted value).
        /// </param>
        /// <param name="onException">An action that accepts a context object, the Exception thrown, and 14 args.</param>
        public static void ApplicationInsights_AddCallbacks(int methodId,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object> onBegin,
            Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object> onEnd,
            Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object, object, object> onException)
        {
           for (int i = 0; i < 20; ++i)
           {
                int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock14, 1, 0);

                if (originalValue == 0)
                {
                    try
                    {
                        // this thread updated lock14
                        var newBeginCallbacks14 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks14);
                        var newEndCallbacks14 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks14);
                        var newExceptionCallbacks14 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks14);

                        newBeginCallbacks14.Add(methodId, onBegin);
                        newEndCallbacks14.Add(methodId, onEnd);
                        newExceptionCallbacks14.Add(methodId, onException);

                        BCB<int>.callbacks14 = newBeginCallbacks14;
                        ECB<int>.callbacks14 = newEndCallbacks14;
                        ExCB<int>.callbacks14 = newExceptionCallbacks14;
                    }
                    finally
                    {
                        BCB<int>.Lock14 = 0;
                    }

                    break;
                }

                // some other thread updated Lock14; wait and try again
                if (i < 19)
                {
                    Thread.Sleep(5);
                }
                else
                {
                     throw new InvalidOperationException("Could not add callbacks because of the concurrency issue.");
                }
            }
        }

#pragma warning disable CA1506 // Avoid excessive class coupling
#pragma warning disable CA1502 // Avoid excessive complexity
        public static void ApplicationInsights_RemoveCallbacks(int methodId, int argsCount)
        {
            switch (argsCount)
            {
                case 0 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock0, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock0
                                var newBeginCallbacks0 = new Dictionary<int, Func<object>>(BCB<int>.callbacks0);
                                var newEndCallbacks0 = new Dictionary<int, Func<object, object, object>>(ECB<int>.callbacks0);
                                var newExceptionCallbacks0 = new Dictionary<int, Action<object, Exception>>(ExCB<int>.callbacks0);

                                newBeginCallbacks0.Remove(methodId);
                                newEndCallbacks0.Remove(methodId);
                                newExceptionCallbacks0.Remove(methodId);

                                BCB<int>.callbacks0 = newBeginCallbacks0;
                                ECB<int>.callbacks0 = newEndCallbacks0;
                                ExCB<int>.callbacks0 = newExceptionCallbacks0;
                            }
                            finally
                            {
                                BCB<int>.Lock0 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock0; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 1 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock1, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock1
                                var newBeginCallbacks1 = new Dictionary<int, Func<object, object>>(BCB<int>.callbacks1);
                                var newEndCallbacks1 = new Dictionary<int, Func<object, object, object, object>>(ECB<int>.callbacks1);
                                var newExceptionCallbacks1 = new Dictionary<int, Action<object, Exception, object>>(ExCB<int>.callbacks1);

                                newBeginCallbacks1.Remove(methodId);
                                newEndCallbacks1.Remove(methodId);
                                newExceptionCallbacks1.Remove(methodId);

                                BCB<int>.callbacks1 = newBeginCallbacks1;
                                ECB<int>.callbacks1 = newEndCallbacks1;
                                ExCB<int>.callbacks1 = newExceptionCallbacks1;
                            }
                            finally
                            {
                                BCB<int>.Lock1 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock1; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 2 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock2, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock2
                                var newBeginCallbacks2 = new Dictionary<int, Func<object, object, object>>(BCB<int>.callbacks2);
                                var newEndCallbacks2 = new Dictionary<int, Func<object, object, object, object, object>>(ECB<int>.callbacks2);
                                var newExceptionCallbacks2 = new Dictionary<int, Action<object, Exception, object, object>>(ExCB<int>.callbacks2);

                                newBeginCallbacks2.Remove(methodId);
                                newEndCallbacks2.Remove(methodId);
                                newExceptionCallbacks2.Remove(methodId);

                                BCB<int>.callbacks2 = newBeginCallbacks2;
                                ECB<int>.callbacks2 = newEndCallbacks2;
                                ExCB<int>.callbacks2 = newExceptionCallbacks2;
                            }
                            finally
                            {
                                BCB<int>.Lock2 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock2; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 3 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock3, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock3
                                var newBeginCallbacks3 = new Dictionary<int, Func<object, object, object, object>>(BCB<int>.callbacks3);
                                var newEndCallbacks3 = new Dictionary<int, Func<object, object, object, object, object, object>>(ECB<int>.callbacks3);
                                var newExceptionCallbacks3 = new Dictionary<int, Action<object, Exception, object, object, object>>(ExCB<int>.callbacks3);

                                newBeginCallbacks3.Remove(methodId);
                                newEndCallbacks3.Remove(methodId);
                                newExceptionCallbacks3.Remove(methodId);

                                BCB<int>.callbacks3 = newBeginCallbacks3;
                                ECB<int>.callbacks3 = newEndCallbacks3;
                                ExCB<int>.callbacks3 = newExceptionCallbacks3;
                            }
                            finally
                            {
                                BCB<int>.Lock3 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock3; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 4 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock4, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock4
                                var newBeginCallbacks4 = new Dictionary<int, Func<object, object, object, object, object>>(BCB<int>.callbacks4);
                                var newEndCallbacks4 = new Dictionary<int, Func<object, object, object, object, object, object, object>>(ECB<int>.callbacks4);
                                var newExceptionCallbacks4 = new Dictionary<int, Action<object, Exception, object, object, object, object>>(ExCB<int>.callbacks4);

                                newBeginCallbacks4.Remove(methodId);
                                newEndCallbacks4.Remove(methodId);
                                newExceptionCallbacks4.Remove(methodId);

                                BCB<int>.callbacks4 = newBeginCallbacks4;
                                ECB<int>.callbacks4 = newEndCallbacks4;
                                ExCB<int>.callbacks4 = newExceptionCallbacks4;
                            }
                            finally
                            {
                                BCB<int>.Lock4 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock4; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 5 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock5, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock5
                                var newBeginCallbacks5 = new Dictionary<int, Func<object, object, object, object, object, object>>(BCB<int>.callbacks5);
                                var newEndCallbacks5 = new Dictionary<int, Func<object, object, object, object, object, object, object, object>>(ECB<int>.callbacks5);
                                var newExceptionCallbacks5 = new Dictionary<int, Action<object, Exception, object, object, object, object, object>>(ExCB<int>.callbacks5);

                                newBeginCallbacks5.Remove(methodId);
                                newEndCallbacks5.Remove(methodId);
                                newExceptionCallbacks5.Remove(methodId);

                                BCB<int>.callbacks5 = newBeginCallbacks5;
                                ECB<int>.callbacks5 = newEndCallbacks5;
                                ExCB<int>.callbacks5 = newExceptionCallbacks5;
                            }
                            finally
                            {
                                BCB<int>.Lock5 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock5; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 6 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock6, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock6
                                var newBeginCallbacks6 = new Dictionary<int, Func<object, object, object, object, object, object, object>>(BCB<int>.callbacks6);
                                var newEndCallbacks6 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks6);
                                var newExceptionCallbacks6 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object>>(ExCB<int>.callbacks6);

                                newBeginCallbacks6.Remove(methodId);
                                newEndCallbacks6.Remove(methodId);
                                newExceptionCallbacks6.Remove(methodId);

                                BCB<int>.callbacks6 = newBeginCallbacks6;
                                ECB<int>.callbacks6 = newEndCallbacks6;
                                ExCB<int>.callbacks6 = newExceptionCallbacks6;
                            }
                            finally
                            {
                                BCB<int>.Lock6 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock6; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 7 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock7, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock7
                                var newBeginCallbacks7 = new Dictionary<int, Func<object, object, object, object, object, object, object, object>>(BCB<int>.callbacks7);
                                var newEndCallbacks7 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks7);
                                var newExceptionCallbacks7 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object>>(ExCB<int>.callbacks7);

                                newBeginCallbacks7.Remove(methodId);
                                newEndCallbacks7.Remove(methodId);
                                newExceptionCallbacks7.Remove(methodId);

                                BCB<int>.callbacks7 = newBeginCallbacks7;
                                ECB<int>.callbacks7 = newEndCallbacks7;
                                ExCB<int>.callbacks7 = newExceptionCallbacks7;
                            }
                            finally
                            {
                                BCB<int>.Lock7 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock7; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 8 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock8, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock8
                                var newBeginCallbacks8 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks8);
                                var newEndCallbacks8 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks8);
                                var newExceptionCallbacks8 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks8);

                                newBeginCallbacks8.Remove(methodId);
                                newEndCallbacks8.Remove(methodId);
                                newExceptionCallbacks8.Remove(methodId);

                                BCB<int>.callbacks8 = newBeginCallbacks8;
                                ECB<int>.callbacks8 = newEndCallbacks8;
                                ExCB<int>.callbacks8 = newExceptionCallbacks8;
                            }
                            finally
                            {
                                BCB<int>.Lock8 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock8; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 9 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock9, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock9
                                var newBeginCallbacks9 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks9);
                                var newEndCallbacks9 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks9);
                                var newExceptionCallbacks9 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks9);

                                newBeginCallbacks9.Remove(methodId);
                                newEndCallbacks9.Remove(methodId);
                                newExceptionCallbacks9.Remove(methodId);

                                BCB<int>.callbacks9 = newBeginCallbacks9;
                                ECB<int>.callbacks9 = newEndCallbacks9;
                                ExCB<int>.callbacks9 = newExceptionCallbacks9;
                            }
                            finally
                            {
                                BCB<int>.Lock9 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock9; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 10 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock10, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock10
                                var newBeginCallbacks10 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks10);
                                var newEndCallbacks10 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks10);
                                var newExceptionCallbacks10 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks10);

                                newBeginCallbacks10.Remove(methodId);
                                newEndCallbacks10.Remove(methodId);
                                newExceptionCallbacks10.Remove(methodId);

                                BCB<int>.callbacks10 = newBeginCallbacks10;
                                ECB<int>.callbacks10 = newEndCallbacks10;
                                ExCB<int>.callbacks10 = newExceptionCallbacks10;
                            }
                            finally
                            {
                                BCB<int>.Lock10 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock10; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 11 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock11, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock11
                                var newBeginCallbacks11 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks11);
                                var newEndCallbacks11 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks11);
                                var newExceptionCallbacks11 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks11);

                                newBeginCallbacks11.Remove(methodId);
                                newEndCallbacks11.Remove(methodId);
                                newExceptionCallbacks11.Remove(methodId);

                                BCB<int>.callbacks11 = newBeginCallbacks11;
                                ECB<int>.callbacks11 = newEndCallbacks11;
                                ExCB<int>.callbacks11 = newExceptionCallbacks11;
                            }
                            finally
                            {
                                BCB<int>.Lock11 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock11; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 12 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock12, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock12
                                var newBeginCallbacks12 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks12);
                                var newEndCallbacks12 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks12);
                                var newExceptionCallbacks12 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks12);

                                newBeginCallbacks12.Remove(methodId);
                                newEndCallbacks12.Remove(methodId);
                                newExceptionCallbacks12.Remove(methodId);

                                BCB<int>.callbacks12 = newBeginCallbacks12;
                                ECB<int>.callbacks12 = newEndCallbacks12;
                                ExCB<int>.callbacks12 = newExceptionCallbacks12;
                            }
                            finally
                            {
                                BCB<int>.Lock12 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock12; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 13 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock13, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock13
                                var newBeginCallbacks13 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks13);
                                var newEndCallbacks13 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks13);
                                var newExceptionCallbacks13 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks13);

                                newBeginCallbacks13.Remove(methodId);
                                newEndCallbacks13.Remove(methodId);
                                newExceptionCallbacks13.Remove(methodId);

                                BCB<int>.callbacks13 = newBeginCallbacks13;
                                ECB<int>.callbacks13 = newEndCallbacks13;
                                ExCB<int>.callbacks13 = newExceptionCallbacks13;
                            }
                            finally
                            {
                                BCB<int>.Lock13 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock13; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
                case 14 :
                    for (int i = 0; i < 20; ++i)
                    {
                        int originalValue = Interlocked.CompareExchange(ref BCB<int>.Lock14, 1, 0);

                        if (originalValue == 0)
                        {
                            try
                            {
                                // this thread updated lock14
                                var newBeginCallbacks14 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(BCB<int>.callbacks14);
                                var newEndCallbacks14 = new Dictionary<int, Func<object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ECB<int>.callbacks14);
                                var newExceptionCallbacks14 = new Dictionary<int, Action<object, Exception, object, object, object, object, object, object, object, object, object, object, object, object, object, object>>(ExCB<int>.callbacks14);

                                newBeginCallbacks14.Remove(methodId);
                                newEndCallbacks14.Remove(methodId);
                                newExceptionCallbacks14.Remove(methodId);

                                BCB<int>.callbacks14 = newBeginCallbacks14;
                                ECB<int>.callbacks14 = newEndCallbacks14;
                                ExCB<int>.callbacks14 = newExceptionCallbacks14;
                            }
                            finally
                            {
                                BCB<int>.Lock14 = 0;
                            }

                            break;
                        }

                        // some other thread updated Lock14; wait and try again
                        if (i < 19)
                        {
                            Thread.Sleep(5);
                        }
                        else
                        {
                             throw new InvalidOperationException("Could not remove callbacks because of the concurrency issue.");
                        }
                    }

                    break;
            }
        }
#pragma warning restore CA1506 // Avoid excessive class coupling
#pragma warning restore CA1502 // Avoid excessive complexity
    }
}
